# 데이터 파티셔닝과 셔플

스파크의 데이터 파티셔닝은 데이터를 여러 클러스터 노드로 분할하는 매커니즘이다. 스파크 클러스터는 간단히 병렬연산이 가능하고 네트워크로 연결된 머신(노드)들의 집합이라고 할 수 있다. 

스파크에 데이터를 업로드하면, 데이터는 여러 파티션으로 분할되어 클러스터 노드에 고르게 분산저장된다. 

하나의 파티션은 곧 하나의 테스크가 처리해야 할 분량이라고 보면 된다. 만약의 각 파티션이 가지고 있는 데이터의 용량이 너무 크다면 테스크를 실행하는 실행자(Executor)의 메모리를 초과하게 되어 OOM이 발생하는 결과를 초래하게 된다. 따라서, 파티션은 충분한 양으로 분배되는 것이 중요하며, 보통 클러스터의 코어개수보다 서너배 많은 정도가 적당하다고 한다.  

### 셔플링

셔플링은 파티션간의 물리적인 데이터 이동을 의미한다. 셔플링은 새로운 RDD의 파티션을 만들려고 여러 파티션의 데이터를 합칠때 발생한다.

셔플링 이전에 수행한 테스크는 맵(Map) 테스크라고 하며, 셔플링 이후에 수행되는 작업은 리듀스(Reduce) 테스크라고 한다. 

먼저, 맵테스크가 발생하고난 후의 결과는 디스크에 기록된다. 이후 리듀스태스크가 각 파일들을 읽어들이며 작업을 진행한다. 이러한 과정에서 파일을 읽고 쓰는 IO작업이 발생하며 이는 결국 네트워크의 부담을 주게 된다. 





![이미지](/img/shuffle.png)
##### [출처 : https://0x0fff.com/spark-architecture-shuffle/](https://0x0fff.com/spark-architecture-shuffle/)


_위의 사진은 셔플링과 관련되어 메모리를 어떻게 관리해야 하는가에 대해 조사하며 찾은 자료이다. 각각의 파티션에서 map테스크가 발생하면 그 결과물은 storage( 각각 executor의 JVM에서 캐시등의 목적으로 할당된 메모리공간)에 저장된후  sort와 spill에 의해 local directory, 즉 디스크에 저장되게 되며 이를 리듀스 태스크에서 읽어 작업을 진행하는 것을 표현한 듯 하다._

### 셔플링 관련 매개변수

+ 셔플링 알고리즘

        spark.shuffle.manager
    
    hash 혹은 sort로 설정할 수 있으며, sort셔플링이 셔플링에 의한 파일을 현저히 적게 생성하고, 메모리 또한 매우 효율적으로 사용할 수 있어 Default 설정으로 되어있다. 


+ 중간파일 통합여부 지정

        spark.shuffle.consolidateFiles

    xt4나 XFS 파일 시스템을 사용할 경우 true로 변경하는 것이 낫다. ( Defualt false)


+ 셔플링에 사용할 메모리 제한

        spark.shuffle.spill (Default true)

    메모리 제한 임계치를 초과한 데이터는 디스크로 내보낸다. 

    메모리 제한 임계치를 지정하는 매개변수는 `spark.shuffle.memoryFraction`을 통해 지정할 수 있다. 위 설정은 JVM Heap메모리에서 storage에 활용할 메모리를 얼마나 할당할 것인가를 결정하는 설정이다. 그러나 spark 1.6버젼 이후로는 이와 같은 설정을 굳이 하지 않아도 시스템적으로 가장 효율적인 수준에서 메모리를 할당하므로 굳이 설정하지 않아도 무방하며 기본값 그대로 사용하는 것을 가장 추천한다고 한다. 

